    * 隐藏内部实现
        最小特权原则（最小暴露原则）
    * 规避冲突

  ####  区分函数声明和表达式最简单的方法是看function关键字出现在声明的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function 是声明中的第一个词，那么就是一个函数声明，否则是一个函数表达式  

  ### 匿名 和 具名
   ** 匿名有以下几个缺点
    1. 匿名函数在栈追踪中不会显示有意义的函数名，使得调试困难；
    2. 当函数需要引用自身时只能使用过期的 argument.callee ，比如在递归中。还有一个例子，是事件触发后事件监听器需要解绑自身。
    3. 匿名函数降低了代码的可读性，一个描述性函数名也是很重要的；

     > 可以给行内函数表达式指定一个函数名，始终给函数表达式命名是一个最佳实践。
     ```
      setTimeout (function timeoutHandler(){
            console.log('wait 1s');
      },1000)

      ```

   ### 立即执行函数表达式
    * 可以使用具名函数或者匿名函数
    ```
      (function foo(){
          var a = 3 ;
          console.log(a);
      })();
    ```
    > 还有一种等效写法
    ```
    (function foo(){
        var a = 3 ;
        console.log(a);
    }())
    ``` 
    IIFE 有一种用途是倒置代码运行顺序，将要运行的函数放在第二位。这种模式在UMD项目中被广泛使用。
    
    ### 块作用域
    with,try/catch(声明的变量仅在catch 内部有效)

    let const



